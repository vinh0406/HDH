#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/wait.h>

#define MAX_LINE 80  /* Độ dài tối đa của lệnh */
char history[MAX_LINE]; /* Lưu lệnh gần nhất */
int backgroundJobCounter = 0; // Đếm số thứ tự job

/* Hàm phân tích chuỗi lệnh */
void parseInput(char *input, char **args) {
    int i = 0;
    args[i] = strtok(input, " ");
    while (args[i] != NULL) {
        i++;
        args[i] = strtok(NULL, " ");
    }
}

/* Hàm thực thi lệnh cơ bản */
void executeCommand(char **args, int background) {
    pid_t pid = fork();
    if (pid == 0) { // Tiến trình con
        execvp(args[0], args);
        perror("Error executing command");
        exit(0);
    } else if (pid > 0) { // Tiến trình cha
        if (!background) { // Chờ nếu không chạy nền
            waitpid(pid, NULL, 0);
        }

        else { // Xử lý lệnh chạy nền
            backgroundJobCounter++;
            printf("[%d] %d\n", backgroundJobCounter, pid); // In thông tin job
        }
    } else {
        perror("Fork failed");
    }
}

/* Hàm xử lý chuyển hướng đầu vào/đầu ra */
int handleRedirection(char **args) {
    int fd;
    int stdin_backup = dup(STDIN_FILENO);  // Lưu stdin gốc
    int stdout_backup = dup(STDOUT_FILENO); // Lưu stdout gốc

    for (int i = 0; args[i] != NULL; i++) {
        if (strcmp(args[i], ">") == 0) {
            if (args[i + 1] == NULL) {
                fprintf(stderr, "Error: Missing output file.\n");
                return -1;
            }
            fd = open(args[i + 1], O_CREAT | O_WRONLY | O_TRUNC, S_IRWXU);
            if (fd == -1) {
                perror("Error opening output file");
                return -1;
            }
            dup2(fd, STDOUT_FILENO);
            close(fd);
            args[i] = NULL;
        } else if (strcmp(args[i], "<") == 0) {
            if (args[i + 1] == NULL) {
                fprintf(stderr, "Error: Missing input file.\n");
                return -1;
            }
            fd = open(args[i + 1], O_RDONLY);
            if (fd == -1) {
                perror("Error opening input file");
                return -1;
            }
            dup2(fd, STDIN_FILENO);
            close(fd);
            args[i] = NULL;
        }
    }

    return 0;
}

/* Hàm thực thi lệnh với khôi phục stdin và stdout */
void executeCommandWithRedirection(char **args, int background) {
    int stdin_backup = dup(STDIN_FILENO);  // Lưu stdin gốc
    int stdout_backup = dup(STDOUT_FILENO); // Lưu stdout gốc

    if (handleRedirection(args) == -1) {
        dup2(stdin_backup, STDIN_FILENO);  // Khôi phục stdin
        dup2(stdout_backup, STDOUT_FILENO); // Khôi phục stdout
        close(stdin_backup);
        close(stdout_backup);
        return;
    }

    executeCommand(args, background);

    // Khôi phục stdin và stdout sau khi thực thi lệnh
    dup2(stdin_backup, STDIN_FILENO);
    dup2(stdout_backup, STDOUT_FILENO);
    close(stdin_backup);
    close(stdout_backup);
}

/* Hàm xử lý ống */
void executePipe(char **args1, char **args2, int background) {
    int fd[2];
    pipe(fd);
    pid_t pid1 = fork();

    if (pid1 == 0) { // Tiến trình con 1
        dup2(fd[1], STDOUT_FILENO);
        close(fd[0]);
        close(fd[1]);
        handleRedirection(args1);
        execvp(args1[0], args1);
        perror("Error in pipe execution");
        exit(1);
    }

    pid_t pid2 = fork();

    if (pid2 == 0) { // Tiến trình con 2
        dup2(fd[0], STDIN_FILENO);
        close(fd[1]);
        close(fd[0]);
        handleRedirection(args2);
        execvp(args2[0], args2);
        perror("Error in pipe execution");
        exit(1);
    }

    close(fd[0]);
    close(fd[1]);

    if (!background) {
        waitpid(pid1, NULL, 0);
        waitpid(pid2, NULL, 0);
    }
}

/* Hàm xử lý lịch sử */
void handleHistory(char **args, int background) {
    if (strlen(history) == 0) {
        printf("No commands in history.\n");
        return;
    }

    if (background) { // Trường hợp `!! &`
        if (strstr(history, "&") != NULL) { // Lệnh lịch sử đã có dấu `&`
            printf("Error: command & &\n");
            return;
        }
    }

    printf("Executing last command: %s\n", history);

    // Tách lệnh từ lịch sử thành các token
    char *historyArgs[MAX_LINE / 2 + 1];
    parseInput(history, historyArgs);

    for (int i = 0; historyArgs[i] != NULL; i++) {
        if (strcmp(historyArgs[i], "&") == 0) {
            background = 1;
            historyArgs[i] = NULL;
        }
    }

    // Xử lý lệnh từ lịch sử
    int pipeIndex = -1;
    for (int i = 0; historyArgs[i] != NULL; i++) {
        if (strcmp(historyArgs[i], "|") == 0) {
            pipeIndex = i;
            break;
        }
    }

    if (pipeIndex != -1) { // Nếu lệnh có ống
        historyArgs[pipeIndex] = NULL;
        char *args1[MAX_LINE / 2 + 1];
        char *args2[MAX_LINE / 2 + 1];

        // Tách hai lệnh ở hai bên dấu ống
        memcpy(args1, historyArgs, pipeIndex * sizeof(char *));
        args1[pipeIndex] = NULL;
        parseInput(history + (historyArgs[pipeIndex + 1] - history), args2);

        executePipe(args1, args2, background);
    } else {
        executeCommandWithRedirection(historyArgs, background);
    }
}

/* Hàm chính */
int main(void) {
    char input[MAX_LINE];          // Lệnh nhập vào
    char *args[MAX_LINE / 2 + 1];  // Lưu token lệnh
    int shouldRun = 1;             // Duy trì vòng lặp shell

    while (shouldRun) {
        printf("osh> ");
        fflush(stdout);

        fgets(input, MAX_LINE, stdin);

        // Loại bỏ ký tự xuống dòng
        input[strcspn(input, "\n")] = '\0';

        // Lưu lệnh vào lịch sử nếu không phải !!, !! &
        if (strcmp(input, "!!") != 0 && strcmp(input, "!! &") != 0) {
            strcpy(history, input);
        }

        // Loại bỏ khoảng trắng đầu và cuối chuỗi
        char *start = input;
        while (*start == ' ') start++; // Bỏ qua khoảng trắng đầu
        if (strlen(start) == 0) {
            continue;
        }

        // Kiểm tra người dùng nhập "exit"
        if (strcmp(input, "exit") == 0) {
            shouldRun = 0;
            continue;
        }

        // Phân tích lệnh
        parseInput(input, args);

        // Xử lý chạy nền
        int background = 0;
        for (int i = 0; args[i] != NULL; i++) {
            if (strcmp(args[i], "&") == 0) {
                background = 1;
                args[i] = NULL;
            }
        }

        int pipeIndex = -1; // Vị trí của dấu "|"
            for (int i = 0; args[i] != NULL; i++) {
                if (strcmp(args[i], "|") == 0) {
                    pipeIndex = i;
                    break;
                }
            }

        // Xử lý các chức năng đặc biệt
        if (strcmp(args[0], "!!") == 0) {  // Tính năng lịch sử
            handleHistory(args, background);
        } else if (pipeIndex != -1) { // Nếu tìm thấy dấu "|"
            args[pipeIndex] = NULL; // Chia tách lệnh trước và sau "|"
            char *args1[MAX_LINE / 2 + 1];
            char *args2[MAX_LINE / 2 + 1];

            // Sao chép lệnh bên trái "|"
            for (int i = 0; i < pipeIndex; i++) {
                args1[i] = args[i];
            }
            args1[pipeIndex] = NULL;

            // Sao chép lệnh bên phải "|"
            int j = 0;
            for (int i = pipeIndex + 1; args[i] != NULL; i++) {
                args2[j++] = args[i];
            }
            args2[j] = NULL;

            // Thực thi lệnh ống
            executePipe(args1, args2, background);
        } else { // Lệnh cơ bản với chuyển hướng
            executeCommandWithRedirection(args, background);
        }
    }
    return 0;
}
